\chapter{Linking}

\label{linking}

Now that a mesh can be generated, the next challenge is to find a method for linking the mesh structure to the Gaussian splat. These links will ensure that the underlying structure and Gaussian splat remain connected and synchronized at all times. 

A link acts as a carrier of information, defining what properties the Gaussian splat can read from the mesh and what properties the mesh can extract from the Gaussian splat. This bidirectional flow of information allows both components to dynamically influence each other. To ensure that the links function as expected and maintain this synchronization, several key properties must be defined and adhered to.

\begin{enumerate}
    \item \textbf{Bidirectional Association}:  
    Links must provide information flow in both directions:  
    \begin{itemize}
        \item \textit{Mesh to Splat}: The link specifies which properties of the mesh need to be communicated to the Gaussian splat. This allows the splat to reflects changes made to the mesh structure.  
        \item \textit{Splat to Mesh}: Conversely, the link must also define which attributes of the Gaussian splat are relevant to the mesh, allowing the mesh to extract information from its neighboring Gaussian points.  
    \end{itemize}

    \item \textbf{Proximity-Based Propagation}:  
    The strength of the relationship defined by a link should not be uniform, it should depend on proximity. Links to surface points on the mesh that are nearer to the Gaussian point should carry more weight, allowing local interactions. Conversely, links to surface points farther away should carry less weight, reducing the impact of distant changes.  

    \item \textbf{Efficiency}:  
    To handle potentially large numbers of Gaussian splats and mesh points, links must be implemented efficiently:  
    \begin{itemize}
        \item \textit{Memory Constraints}: Each link must use a limited amount of memory, as GPU resources are finite.  
        \item \textit{Performance Constraints}: All links should be established in advance, avoiding the need for real-time computation during runtime. This reduces computational overhead and ensures smooth, real-time performance.
    \end{itemize}
\end{enumerate}


\subsubsection*{Ideal Linking Approach}

In a perfect scenario, links would provide a connection between each Gaussian point and each point on the continuous mesh surface. This would allow each Gaussian splat to respond to any change in the mesh and vice versa. The Gaussian splat would essentially act as a function of the mesh's geometry, with links serving as weighted connections that encode the influence of each mesh point.

However, in this case meshes are discrete structures composed of triangles, making such continuous connections break the third property. To overcome this limitation, \textbf{anchor points} on the mesh are created as an approximation.


\subsubsection*{Dual-Link System for Bi-directionality}

While anchor points provide a feasible linking mechanism, achieving full bi-directionality with fixed buffers presents a challenge. The core issue arises from the asymmetry in how information is shared between the Gaussian splat and the mesh:  

\begin{itemize}
    \item \textit{Splat to Mesh Only}: If only splat-to-mesh links are used, each Gaussian point will have a finite set of anchors, typically its nearest $x$ surface points. While this enables each Gaussian point to get information from these anchors, the mesh cannot necessarily extract the required information from its neighboring Gaussian points since there is no guarantee that these points have links with the anchor point. For example, if a Gaussian point has 10 anchor points in its neighborhood but is only allowed to have four links, only four of the 10 anchors will be able to extract data from that Gaussian point.
    \item \textit{Mesh to Splat Only}: Conversely, if only mesh-to-splat links are used, each mesh anchor will have access to nearby splats, enabling the mesh to extract relevant properties. However, Gaussian points not directly linked to a particular anchor cannot always receive updates, which degrades the synchronization from the mesh to the Gaussian splat.
\end{itemize}

This issue could be fixed by creating a dynamically sized array on 

The inherent limitation of single-direction links is that they only account for one side of the relationship. To ensure that information can flow in both directions, allowing splats to respond to mesh changes and mesh points to reflect splat properties, a \textbf{dual-link system} is required.  

\begin{itemize}
    \item \textit{Forward Links}: These links define what properties the mesh must communicate to the Gaussian splats.  
    \item \textit{Backward Links}: These links define what properties the Gaussian splats must communicate to the mesh.  
\end{itemize}

This dual-link system ensures that all relevant properties are exchanged bidirectionally. The advantage of this approach is that we can pass different properties over the forward and backward links, offering more flexibility in what information is communicated. 

The main downside is that approximately twice as many links are required, which will increase memory usage and computational overhead. However, this trade-off is necessary to ensure full bi-directionality and to maintain the three desired properties of the linking system: bidirectional association, proximity-based propagation, and efficiency. While neither link set alone meets all requirements, combining them achieves the three desired properties effectively.

\input{thesis/linking/anchor_points}

\input{thesis/linking/weight_method}

\section{Forward Linking}

Forward linking enables Gaussian points to gather information from their associated mesh anchors. By ensuring that Gaussian points are aware of their immediate surroundings on the mesh, forward linking allows for local adjustments, improving the accuracy of the splat’s behavior. Furthermore, limiting the number of links in the buffer helps to maintain efficient memory usage, which is crucial for GPU-based implementations. This approach balances performance and memory constraints while still providing localized information for the Gaussian points.

Each Gaussian point is assigned a finite buffer of links to specific anchor points on the mesh, typically chosen based on proximity, such as the nearest vertices or the closest points on the mesh's surface. During precomputation, the links and their respective weights are calculated and stored in the buffer. This process ensures that only relevant mesh anchors are linked, optimizing memory usage. Per link the following information is transferred

The best anchors to use here are Triangle anchors. There are two main reasons for this. First is their quality. Out of the three discussed methods, anchor weights give the best result by far. Second, the amount of detail in the mesh matters less. If vertex based linking would be used, even if a Gaussian point is very close the the surface of the mesh, if the vertices that define this surface are far away, the weights will be low and the 

\textbf{Weight} : Mahalanobis + Euclidean Weight

\section{Backward Linking}

Backward linking enables mesh anchor points to access and utilize the properties of Gaussian points in their neighborhood. The primary purpose of backward linking is to ensure that the mesh can derive relevant properties from the Gaussian splat, such as density, average color, or transformation details. This process enhances the data flow between the mesh and the splat, allowing the mesh to dynamically retrieve important information, thereby enriching the mesh’s attributes with splat data.

In backward linking, each mesh anchor is associated with a finite buffer of links to Gaussian points within a certain proximity. Similar to forward linking, these links are precomputed based on a eulerian

The \textbf{Anchor points} will always be chosen from the full set of vertices defined by the mesh. The entire purpose of the backward links is to have information about the Gaussian splat when we transform it. Since mesh transformations will always be applied on the vertices of the mesh, it makes most sense to have these extracted properties here.

Each link will receive a \textbf{weight} decided by the euclidean weight method. This weight will be normalised over all links so that the sum adds to one. This allows us to take an average of properties with a linear combination.