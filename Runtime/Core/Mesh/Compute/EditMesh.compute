#define GROUP_SIZE 1024

#include "../../Gaussian/Compute/GaussianSplatting.hlsl"

#pragma kernel CSSelectionUpdate
#pragma kernel CSVertexTransform

RWStructuredBuffer<float3> _VertexModPos;
RWByteAddressBuffer _VertexSelectedBits;
uint _VertexCount;
uint _SplatCount;
float4 _SelectionRect;

float4x4 _MatrixObjectToWorld;
float4x4 _MatrixVP;
float4 _VecScreenParams;

[numthreads(GROUP_SIZE,1,1)]
void CSSelectionUpdate (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _VertexCount)
        return;

    float3 pos = _VertexModPos[idx];

    float3 centerWorldPos = mul(_MatrixObjectToWorld, float4(pos,1)).xyz;
    float4 centerClipPos = mul(_MatrixVP, float4(centerWorldPos, 1));
    bool behindCam = centerClipPos.w <= 0;
    if (behindCam)
        return;

    float2 pixelPos = (centerClipPos.xy / centerClipPos.w * float2(0.5, -0.5) + 0.5) * _VecScreenParams.xy;
    if (pixelPos.x < _SelectionRect.x || pixelPos.x > _SelectionRect.z ||
        pixelPos.y < _SelectionRect.y || pixelPos.y > _SelectionRect.w)
    {
        return;
    }
    uint wordIdx = idx / 32;
    uint bitIdx = idx & 31;
    if (true)
        _VertexSelectedBits.InterlockedOr(wordIdx * 4, 1u << bitIdx); // +
    else
        _VertexSelectedBits.InterlockedAnd(wordIdx * 4, ~(1u << bitIdx)); // -
}


float3 _PositionDiff;
float4 _RotationDiff; // _RotationDiff4
float3 _ScaleDiff;
float3 _PivotPoint; // pivot point for rotation and scale


// Function to convert a quaternion to a 4x4 rotation matrix
float4x4 QuaternionToMatrix(float4 quat)
{
    float x = quat.x;
    float y = quat.y;
    float z = quat.z;
    float w = quat.w;

    float x2 = x + x;
    float y2 = y + y;
    float z2 = z + z;
    float xx = x * x2;
    float xy = x * y2;
    float xz = x * z2;
    float yy = y * y2;
    float yz = y * z2;
    float zz = z * z2;
    float wx = w * x2;
    float wy = w * y2;
    float wz = w * z2;

    float4x4 mat;
    mat[0] = float4(1.0f - (yy + zz), xy - wz, xz + wy, 0.0f);
    mat[1] = float4(xy + wz, 1.0f - (xx + zz), yz - wx, 0.0f);
    mat[2] = float4(xz - wy, yz + wx, 1.0f - (xx + yy), 0.0f);
    mat[3] = float4(0.0f, 0.0f, 0.0f, 1.0f);

    return mat;
}

[numthreads(GROUP_SIZE, 1, 1)]
void CSVertexTransform(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _VertexCount)
        return;

    uint wordIndex = idx >> 5;  // Divide by 32 to get word index
    uint bitPosition = idx & 31; // Get position within the 32-bit word (0-31)

    // Load the 32-bit word containing our bit
    uint selectionWord = _VertexSelectedBits.Load(wordIndex * 4);

    // Extract the specific bit for this vertex
    uint isBitSet = (selectionWord >> bitPosition) & 1;

    if (isBitSet) {
        // Read the base vertex position
        float3 basePos = _VertexModPos[idx].xyz;

        // Apply position translation
        float3 translatedPos = basePos + _PositionDiff;

        // Translate to origin (relative to pivot)
        translatedPos -= _PivotPoint;

        // Apply rotation
        float4x4 rotationMatrix = QuaternionToMatrix(_RotationDiff);  // Convert quaternion to rotation matrix
        float3 rotatedPos = mul(rotationMatrix, float4(translatedPos, 1.0f)).xyz;  // Rotate using matrix multiplication

        // Translate back from origin
        rotatedPos += _PivotPoint;

        // Apply scaling relative to pivot
        float3 scaledPos = (rotatedPos - _PivotPoint) * (1.0f + _ScaleDiff);

        // Translate back and calculate the modified position
        float3 finalPos = scaledPos + _PivotPoint;

        // Write the modified position to the _VertexModPos buffer
        _VertexModPos[idx] = float4(finalPos, 1.0f); // Assuming _VertexModPos is a float4 buffer
    }
}