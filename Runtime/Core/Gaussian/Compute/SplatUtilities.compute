// SPDX-License-Identifier: MIT
#define GROUP_SIZE 1024

#pragma kernel CSSetIndices
#pragma kernel CSCalcDistances
#pragma kernel CSCalcViewData
#pragma kernel CSUpdateEditData
#pragma kernel CSInitEditData
#pragma kernel CSClearBuffer
#pragma kernel CSInvertSelection
#pragma kernel CSSelectAll
#pragma kernel CSOrBuffers
#pragma kernel CSSelectionUpdate
#pragma kernel CSTranslateSelection
#pragma kernel CSRotateSelection
#pragma kernel CSScaleSelection
#pragma kernel CSExportData
#pragma kernel CSCopySplats

// DeviceRadixSort
#pragma kernel InitDeviceRadixSort
#pragma kernel Upsweep
#pragma kernel Scan
#pragma kernel Downsweep

// GPU sorting needs wave ops
#pragma require wavebasic

#pragma use_dxc

#include "DeviceRadixSort.hlsl"
#include "GaussianSplatting.hlsl"
#include "ColorMixer.hlsl"
#include "../../Mesh/Compute/MeshUtilities.hlsl"
#include "../../Mesh/Compute/OffscreenUtilities.hlsl"
#include "../../Links/Compute/LinkUtilities.hlsl"


#define QUATERNION_IDENTITY float4(0, 0, 0, 1)

#ifndef PI
#define PI 3.14159265359f
#endif 

static const float EPSILON = 1e-10;
static const int MAX_ITERATIONS = 10;



struct Tetrahedron {
    float3 v0;
    float3 v1;
    float3 v2;
    float3 v3;
};


struct ModSplat {
    float3 pos;
    float4 rot;
    float3 scale;
    half4 color;
};

float4x4 _MatrixObjectToWorld;
float4x4 _MatrixWorldToObject;
// float4x4 _MatrixVP;
float4x4 _MatrixMV;
float4x4 _MatrixP;
// float4 _VecScreenParams;
float4 _VecWorldSpaceCameraPos;
int _SelectionMode;
// uint _ColorClustersPerChannel;

RWStructuredBuffer<uint> _SplatSortDistances;
RWStructuredBuffer<uint> _SplatSortKeys;

uint _SplatCount;

// radix sort etc. friendly, see http://stereopsis.com/radix.html
uint FloatToSortableUint(float f)
{
    uint fu = asuint(f);
    uint mask = -((int)(fu >> 31)) | 0x80000000;
    return fu ^ mask;
}

[numthreads(GROUP_SIZE,1,1)]
void CSSetIndices (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    _SplatSortKeys[idx] = idx;
}

Tetrahedron computeTetrahedronFromEllipsoid(float3 center, float3 scale, float4 rotationQuat)
{
    rotationQuat = normalize(rotationQuat);

    float xx = rotationQuat.x * rotationQuat.x;
    float yy = rotationQuat.y * rotationQuat.y;
    float zz = rotationQuat.z * rotationQuat.z;
    float xy = rotationQuat.x * rotationQuat.y;
    float xz = rotationQuat.x * rotationQuat.z;
    float yz = rotationQuat.y * rotationQuat.z;
    float xw = rotationQuat.x * rotationQuat.w;
    float yw = rotationQuat.y * rotationQuat.w;
    float zw = rotationQuat.z * rotationQuat.w;

    float3x3 rotationMatrix = float3x3(
        1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw),
        2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw),
        2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy)
    );

    float3 dir0 = normalize(float3(1, 1, 1)) * scale   / 2;
    float3 dir1 = normalize(float3(-1, -1, 1)) * scale / 2;
    float3 dir2 = normalize(float3(-1, 1, -1)) * scale / 2;
    float3 dir3 = normalize(float3(1, -1, -1)) * scale / 2;

    Tetrahedron t;
    t.v0 = mul(rotationMatrix, dir0) + center;
    t.v1 = mul(rotationMatrix, dir1) + center;
    t.v2 = mul(rotationMatrix, dir2) + center;
    t.v3 = mul(rotationMatrix, dir3) + center;

    return t;
}

float det3x3(
    float m11, float m12, float m13,
    float m21, float m22, float m23,
    float m31, float m32, float m33)
{
    return m11 * (m22 * m33 - m23 * m32) -
           m12 * (m21 * m33 - m23 * m31) +
           m13 * (m21 * m32 - m22 * m31);
}

float4 calculateTetraBarycentricCoordinates(float3 p, float3 v0, float3 v1, float3 v2, float3 v3)
{
    // Compute vectors relative to d
    float3 vd = p - v3;
    float3 va = v0 - v3;
    float3 vb = v1 - v3;
    float3 vc = v2 - v3;

    // Compute determinant of the full system
    float d = det3x3(va.x, vb.x, vc.x,
                     va.y, vb.y, vc.y,
                     va.z, vb.z, vc.z);

    // Compute determinants for each coordinate
    float d1 = det3x3(vd.x, vb.x, vc.x,
                      vd.y, vb.y, vc.y,
                      vd.z, vb.z, vc.z);

    float d2 = det3x3(va.x, vd.x, vc.x,
                      va.y, vd.y, vc.y,
                      va.z, vd.z, vc.z);

    float d3 = det3x3(va.x, vb.x, vd.x,
                      va.y, vb.y, vd.y,
                      va.z, vb.z, vd.z);

    // Compute barycentric coordinates
    float invD = 1.0 / d;
    float4 bary;
    bary.x = d1 * invD;
    bary.y = d2 * invD;
    bary.z = d3 * invD;
    bary.w = 1.0 - bary.x - bary.y - bary.z;

    return bary;
}

float4 quaternionFromMatrix(float3x3 V)
{
    // Ensure right-handed coordinate system
    float3 v2 = cross(
        float3(V[0][0], V[1][0], V[2][0]),
        float3(V[0][1], V[1][1], V[2][1])
    );
    V[0][2] = v2.x;
    V[1][2] = v2.y;
    V[2][2] = v2.z;

    float trace = V[0][0] + V[1][1] + V[2][2];
    float4 q;

    if (trace > 0)
    {
        float s = sqrt(trace + 1.0f) * 2;
        q = float4(
            (V[2][1] - V[1][2]) / s,
            (V[0][2] - V[2][0]) / s,
            (V[1][0] - V[0][1]) / s,
            0.25f * s
        );
    }
    else if (V[0][0] > V[1][1] && V[0][0] > V[2][2])
    {
        float s = sqrt(1.0f + V[0][0] - V[1][1] - V[2][2]) * 2;
        q = float4(
            0.25f * s,
            (V[0][1] + V[1][0]) / s,
            (V[0][2] + V[2][0]) / s,
            (V[2][1] - V[1][2]) / s
        );
    }
    else if (V[1][1] > V[2][2])
    {
        float s = sqrt(1.0f + V[1][1] - V[0][0] - V[2][2]) * 2;
        q = float4(
            (V[0][1] + V[1][0]) / s,
            0.25f * s,
            (V[1][2] + V[2][1]) / s,
            (V[0][2] - V[2][0]) / s
        );
    }
    else
    {
        float s = sqrt(1.0f + V[2][2] - V[0][0] - V[1][1]) * 2;
        q = float4(
            (V[0][2] + V[2][0]) / s,
            (V[1][2] + V[2][1]) / s,
            0.25f * s,
            (V[1][0] - V[0][1]) / s
        );
    }

    // Normalize quaternion
    float len = sqrt(dot(q, q));
    return q / len;
}

void JacobiEigenvalueDecomposition(float3x3 A, out float3 eigenvalues, out float3x3 eigenvectors)
{
    // Initialize eigenvectors to identity matrix
    eigenvectors = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    
    // Copy input matrix (we'll modify it during iterations)
    float3x3 D = A;
    
    const int MAX_ITERATIONS = 50;
    const float EPSILON = 1e-16;
    
    for (int iter = 0; iter < MAX_ITERATIONS; iter++)
    {
        // Find largest off-diagonal element
        float maxOffDiag = 0.0;
        int p = 0, q = 1;
        
        for (int i = 0; i < 3; i++)
        {
            for (int j = i + 1; j < 3; j++)
            {
                float absValue = abs(D[i][j]);
                if (absValue > maxOffDiag)
                {
                    maxOffDiag = absValue;
                    p = i;
                    q = j;
                }
            }
        }
        
        // Check for convergence
        if (maxOffDiag < EPSILON)
            break;
        
        // Compute Jacobi rotation
        float theta = 0.5 * atan2(2.0 * D[p][q], D[p][p] - D[q][q]);
        float c = cos(theta);
        float s = sin(theta);
        
        // Apply rotation to D
        float3x3 J = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
        J[p][p] = c;
        J[p][q] = -s;
        J[q][p] = s;
        J[q][q] = c;
        
        float3x3 temp = mul(transpose(J), mul(D, J));
        D = temp;
        
        // Update eigenvectors
        eigenvectors = mul(eigenvectors, J);
    }
    
    // Extract eigenvalues from diagonal of D
    eigenvalues.x = D[0][0];
    eigenvalues.y = D[1][1];
    eigenvalues.z = D[2][2];
}

bool fitSteinerCircumellipsoid(Tetrahedron t, inout ModSplat result)
{
    // Compute centroid
    float3 center = (t.v0 + t.v1 + t.v2 + t.v3) / 4;

    // Translate points to origin
    float3 c0 = t.v0 - center;
    float3 c1 = t.v1 - center;
    float3 c2 = t.v2 - center;
    float3 c3 = t.v3 - center;

    // Compute covariance matrix
    float3x3 covMatrix = 0;
    covMatrix[0][0] = (c0.x * c0.x + c1.x * c1.x + c2.x * c2.x + c3.x * c3.x) / 4;
    covMatrix[0][1] = (c0.x * c0.y + c1.x * c1.y + c2.x * c2.y + c3.x * c3.y) / 4;
    covMatrix[0][2] = (c0.x * c0.z + c1.x * c1.z + c2.x * c2.z + c3.x * c3.z) / 4;
    covMatrix[1][1] = (c0.y * c0.y + c1.y * c1.y + c2.y * c2.y + c3.y * c3.y) / 4;
    covMatrix[1][2] = (c0.y * c0.z + c1.y * c1.z + c2.y * c2.z + c3.y * c3.z) / 4;
    covMatrix[2][2] = (c0.z * c0.z + c1.z * c1.z + c2.z * c2.z + c3.z * c3.z) / 4;

    covMatrix[1][0] = covMatrix[0][1];
    covMatrix[2][0] = covMatrix[0][2];
    covMatrix[2][1] = covMatrix[1][2];

    // Compute eigenvectors using power iteration
    float3x3 V;
    float3 scale;

    JacobiEigenvalueDecomposition(covMatrix, scale, V);

    // Scale factor for Steiner circumellipsoid
    scale = 2 * sqrt(3 * scale);

    // Convert eigenvectors to quaternion
    float4 rotation = quaternionFromMatrix(V);

    result.pos = center;
    result.scale = scale;
    result.rot = rotation;
    return true;
}


struct TANCCoords {
    float t;
    int edgeIndex;
    float signedDistance;
    float projectDistance;
    int closestCorner;
    bool isCorner;
};

bool isPointInsideTriangle(float3 p, float3 v1, float3 v2, float3 v3)
{
    // Compute normal of the triangle
    float3 edge1 = v2 - v1;
    float3 edge2 = v3 - v1;
    float3 normal = normalize(cross(edge1, edge2));

    // Compute perpendicular projection of point onto the triangle plane
    float projectDistance = dot(normal, p - v1);
    float3 projectedPoint = p - projectDistance * normal;

    // Compute vectors        
    float3 v0 = v2 - v1;
    float3 v1ToV3 = v3 - v1;
    float3 v2ToP = projectedPoint - v1;
    
    // Compute dot products
    float dot00 = dot(v0, v0);
    float dot01 = dot(v0, v1ToV3);
    float dot02 = dot(v0, v2ToP);
    float dot11 = dot(v1ToV3, v1ToV3);
    float dot12 = dot(v1ToV3, v2ToP);

    // Compute barycentric coordinates
    float denom = dot00 * dot11 - dot01 * dot01;
    float u = (dot11 * dot02 - dot01 * dot12) / denom;
    float v = (dot00 * dot12 - dot01 * dot02) / denom;
    float w = 1.0 - u - v;

    // Check if inside the triangle
    return (u >= 0) && (v >= 0) && (w >= 0);
}


float3 planeLineIntersection(float3 p0, float3 p1, float3 v2, float3 l1, float3 l2) {
    float3 v1 = p1 - p0;
    float3 planeNormal = normalize(cross(v1, v2));
    float3 lineDir = l2 - l1;
    float denom = dot(planeNormal, lineDir);

    if (abs(denom) < 1e-6)
        return float3(0, 0, 0); // Parallel case, undefined behavior

    float t = dot(planeNormal, p0 - l1) / denom;
    return l1 + t * lineDir;
}


TANCCoords triangleAlignedNormalizedCoordinates(float3 p, float3 v1, float3 v2, float3 v3) {
    float3 edge1 = v2 - v1;
    float3 edge2 = v3 - v1;
    float3 normal = normalize(cross(edge1, edge2));

    if (dot(normal, normal) < 1e-6) {
        TANCCoords result;
        result.t = 0;
        result.edgeIndex = 0;
        result.signedDistance = 0;
        result.projectDistance = 0;
        result.closestCorner = 0;
        result.isCorner = false;
        return result;
    }
        
    float projectDistance = dot(normal, p - v1);
    float3 projectedPoint = p - projectDistance * normal;

    float3 edges[6] = { v1, v2, v2, v3, v3, v1 };
    float minDistance = 3.402823466e+30; // float max
    float t = 0;
    uint edgeIndex = 0;
    bool isCorner = false;
    uint opposingCorner = 0;

    for (uint i = 0; i < 3; i++) {
        float3 a = edges[i * 2];
        float3 b = edges[i * 2 + 1];
        float3 ab = b - a;
        float3 ap = projectedPoint - a;
        float projection = dot(ap, ab) / dot(ab, ab);
        
        if (projection > 1 || projection < 0) {
            int opposingEdgeIndex = (i + 2) % 3;
            float3 potentialOpposingCorner = edges[(i * 2 + 2) % 6];
            float cornerDistance = length(projectedPoint - potentialOpposingCorner);

            if (cornerDistance < minDistance) {
                minDistance = cornerDistance;
                isCorner = true;
                edgeIndex = opposingEdgeIndex;
                opposingCorner = (i + 1) % 3;

                float3 startEdge = edges[edgeIndex * 2];
                float3 endEdge = edges[edgeIndex * 2 + 1];
                
                float3 cornerMax = normalize(cross(normal, potentialOpposingCorner - startEdge));
                float3 cornerMin = normalize(cross(potentialOpposingCorner - endEdge, normal));
                float3 cornerT = normalize(projectedPoint - potentialOpposingCorner);
                float3 intersect = planeLineIntersection(cornerMin, cornerMax, normal, float3(0,0,0), cornerT);
                t = length(cornerMin - intersect) / length(cornerMin - cornerMax);
            }
        } else {
            float distance = length(projectedPoint - (a + projection * ab));
            if (distance < minDistance) {
                minDistance = distance;
                isCorner = false;
                edgeIndex = i;
                t = projection;
            }
        }
    }

    if (isCorner) {
        TANCCoords result;
        result.t = t;
        result.edgeIndex = edgeIndex;
        result.signedDistance = minDistance;
        result.projectDistance = projectDistance;
        result.closestCorner = opposingCorner;
        result.isCorner = true;
        return result;
    }

    float3 edgeStart = edges[edgeIndex * 2];
    float3 edgeEnd = edges[edgeIndex * 2 + 1];
    float3 edgeDir = normalize(edgeEnd - edgeStart);
    float3 edgeNormal = normalize(cross(edgeDir, normal));
    float signedDistance = dot(p - edgeStart, edgeNormal);

    TANCCoords result;
    result.t = t;
    result.edgeIndex = edgeIndex;
    result.signedDistance = signedDistance;
    result.projectDistance = projectDistance;
    result.closestCorner = 0;
    result.isCorner = false;
    return result;
}

float3 TANCToWorld(TANCCoords tanc, float3 v1, float3 v2, float3 v3) {
    float t = tanc.t;
    int edgeIndex = tanc.edgeIndex;
    float signedDistance = tanc.signedDistance;
    float projectDistance = tanc.projectDistance;

    float3 a, b;
    switch (edgeIndex) {
        case 0: a = v1; b = v2; break;
        case 1: a = v2; b = v3; break;
        case 2: a = v3; b = v1; break;
        default: return float3(0,0,0);
    }

    float3 edge1 = v2 - v1;
    float3 edge2 = v3 - v1;
    float3 triangleNormal = normalize(cross(edge1, edge2));

    if (tanc.isCorner) {
        float3 corner;
        switch (tanc.closestCorner) {
            case 0: corner = v1; break;
            case 1: corner = v2; break;
            case 2: corner = v3; break;
            default: return float3(0,0,0);
        }

        float3 startEdge = a;
        float3 endEdge = b;
        float3 cornerMax = normalize(cross(triangleNormal, corner - startEdge));
        float3 cornerMin = normalize(cross(corner - endEdge, triangleNormal));
        float3 dir = normalize(cornerMin * (1 - t) + cornerMax * t);
        return corner + dir * signedDistance + triangleNormal * projectDistance;
    } else {
        float3 edgeDir = normalize(b - a);
        float3 edgeNormal = normalize(cross(edgeDir, triangleNormal));
        float3 edgePoint = a * (1 - t) + b * t;
        return edgePoint + edgeNormal * signedDistance + triangleNormal * projectDistance;
    }
}



// Calculate the distance from a point to a line segment
float DistanceToEdge(float3 p, float3 edgeStart, float3 edgeEnd) {
    float3 edge = edgeEnd - edgeStart;
    float3 pointToStart = p - edgeStart;

    // Project the point onto the edge
    float t = dot(pointToStart, edge) / dot(edge, edge);

    // Clamp the projection to the segment
    t = clamp(t, 0.0, 1.0);

    // Find the closest point on the edge
    float3 closestPoint = edgeStart + t * edge;

    // Return the distance from the point to the closest point on the edge
    return length(p - closestPoint);
}

// Calculate the barycentric coordinates of a point relative to a triangle
float3 BarycentricCoordinates(float3 p, float3 a, float3 b, float3 c) {
    float3 v0 = b - a;
    float3 v1 = c - a;
    float3 v2 = p - a;

    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);

    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;

    return float3(u, v, w);
}

// Calculate the minimum distance from a point to the surface, edges, or vertices of a triangle
float DistanceToTriangle(Triangle t, float3 p) {
    // Calculate the triangle's normal
    float3 edge1 = t.v1.pos - t.v0.pos;
    float3 edge2 = t.v2.pos - t.v0.pos;
    float3 normal = normalize(cross(edge1, edge2));

    // Calculate the signed distance from the point to the triangle's plane
    float planeDistance = dot(p - t.v0.pos, normal);

    // Project the point onto the triangle's plane
    float3 projectedPoint = p - planeDistance * normal;

    // Calculate barycentric coordinates of the projected point
    float3 barycentric = BarycentricCoordinates(projectedPoint, t.v0.pos, t.v1.pos, t.v2.pos);

    // Check if the projected point is inside the triangle
    bool isInside = (barycentric.x >= 0.0) && (barycentric.y >= 0.0) && (barycentric.z >= 0.0);

    if (isInside) {
        // The closest point is on the surface of the triangle
        return abs(planeDistance); // Perpendicular distance to the plane
    } else {
        // The closest point is on one of the edges or vertices
        float distAB = DistanceToEdge(p, t.v0.pos, t.v1.pos);
        float distBC = DistanceToEdge(p, t.v1.pos, t.v2.pos);
        float distCA = DistanceToEdge(p, t.v2.pos, t.v0.pos);

        float distA = length(p - t.v0.pos);
        float distB = length(p - t.v1.pos);
        float distC = length(p - t.v2.pos);

        return min(min(min(distAB, distBC), distCA), min(min(distA, distB), distC));
    }
}

float3 translatePoint(int splatIndex, float3 p) {
    // Cache splat links data once
    SplatLink currentSplat = LoadSplatLink(splatIndex);
    
    // First pass: gather valid triangles and calculate initial values
    float weights[8];
    int validCount = 0;
    float totalWeight = 0.0;
    int closestId = -1;
    float closestDist = 3.402823466e+30;
    
    // First pass to gather triangle data and determine weights
    [unroll]
    for (int i = 0; i < 8; i++) {
        weights[i] = 0;

        int triangleId = currentSplat.triangleIds[i];
        float triangleWeight = currentSplat.triangleWeights[i];
        
        // Skip invalid triangles early
        if (triangleId == -1 || triangleWeight <= 0) continue;
        
        // Fetch triangle data once
        Triangle t = GetTriangle(triangleId);

        // Calculate triangle properties once
        float3 edge1 = t.v1.pos - t.v0.pos;
        float3 edge2 = t.v2.pos - t.v0.pos;
        float3 crossProduct = cross(edge1, edge2);
        float surfaceArea = 0.5 * length(cross(edge1, edge2));
        if (surfaceArea <= 0.0) continue;
        
        // Cache triangle data for reuse in second pass
        float3 normal = normalize(crossProduct);
        float3 center = (t.v0.pos + t.v1.pos + t.v2.pos) / 3.0;
        
        // Compute perpendicular distance once
        float3 toPoint = p - t.v0.pos;
        float perpDistance = dot(toPoint, normal);
        
        // Project point onto triangle plane once
        float3 projPoint = p - perpDistance * normal;
        
        // Check if point is inside triangle and cache result
        
        // Compute weight based on distance and perpendicular distance
        float distanceToCentroid = length(projPoint - center);
        // float weight = 1 / (exp(DistanceToTriangle(t, p)) + 1e-5);
        float weight = surfaceArea / (exp(distanceToCentroid) * sqrt(abs(perpDistance) + 1e-5));

        if (weight > 0) {
            totalWeight += weight;
            weights[i] = weight;
            validCount++;
        } else {
            weights[i] = 0;
            // Find closest triangle for fallback
            float dist = length(p - center);
            if (dist < closestDist) {
                closestDist = dist;
                closestId = i;
            }
        }        
    }

    // Handle case where no valid weights were found
    if (validCount == 0) {
        if (closestId == -1) {
            return float3(0,0,0);
        }
        weights[closestId] = 1.0;
        totalWeight = 1.0;
    } 
    
    if (totalWeight == 0) {
        return p;
    }

    
    // Second pass: transform point using cached data
    float3 finalPoint = float3(0,0,0);
    [unroll]
    for (int j = 0; j < 8; j++) {
        float normalizedWeight = weights[j] / totalWeight;

        if (normalizedWeight <= 0) continue;
        
        int triangleId = currentSplat.triangleIds[j];
        Triangle t = GetTriangle(triangleId);
        
        bool isInside = isPointInsideTriangle(p, t.v0.pos, t.v1.pos, t.v2.pos);
        if (isInside) {
            // Pre-calculated triangle data
            float3 center = (t.v0.pos + t.v1.pos + t.v2.pos) / 3.0;
            float3 edge1 = t.v1.pos - t.v0.pos;
            float3 edge2 = t.v2.pos - t.v0.pos;
            float3 normal = normalize(cross(edge1, edge2));
            float3 autoVert = center + normal;
            
            // Modified triangle data
            float3 modCenter = (t.v0.pos + t.v1.pos + t.v2.pos + t.v0.posMod + t.v1.posMod + t.v2.posMod) / 3.0;
            
            // Avoid recalculating cross product
            float3 modEdge1 = (t.v1.pos + t.v1.posMod) - (t.v0.pos + t.v0.posMod);
            float3 modEdge2 = (t.v2.pos + t.v2.posMod) - (t.v0.pos + t.v0.posMod);
            float3 modNormal = normalize(cross(modEdge1, modEdge2));
            float3 modAutoVert = modCenter + modNormal;
            
            float4 barycentricCoords = calculateTetraBarycentricCoordinates(p, t.v0.pos, t.v1.pos, t.v2.pos, autoVert);
            
            float3 baryTransformed = barycentricCoords.x * (t.v0.pos + t.v0.posMod) + 
                                     barycentricCoords.y * (t.v1.pos + t.v1.posMod) + 
                                     barycentricCoords.z * (t.v2.pos + t.v2.posMod) + 
                                     barycentricCoords.w * modAutoVert;
            
            finalPoint += baryTransformed * normalizedWeight;
        } else {
            // Use pre-computed TANC coordinates
            TANCCoords tancCoords = triangleAlignedNormalizedCoordinates(p, t.v0.pos, t.v1.pos, t.v2.pos);
            float3 tancTransformed = TANCToWorld(tancCoords, 
                                               t.v0.pos + t.v0.posMod, 
                                               t.v1.pos + t.v1.posMod, 
                                               t.v2.pos + t.v2.posMod);
            
            finalPoint += tancTransformed * normalizedWeight;
        }
    }

    if (abs(totalWeight - 1) < 0.00001) {
        return p;
    }
    
    return finalPoint;
}


half4 getModColor(int splatIndex) {
    half4 avgColor = half4(0, 0, 0, 0);

    SplatLink currentSplat = LoadSplatLink(splatIndex);

    [unroll]
    for (uint i = 0; i < 8; i++) {
        int triangleId = currentSplat.triangleIds[i];
        float triangleWeight = currentSplat.triangleWeights[i];

        if (triangleId < 0 || triangleWeight <= 0) continue;

        // Get the triangle
        Triangle t = GetTriangle(triangleId);

        // Get barycentric coordinates
        float baryV = currentSplat.triangleX[i];
        float baryW = currentSplat.triangleY[i];
        float baryU = 1.0 - baryV - baryW;  // Calculate the first barycentric coordinate

        float3 surfacePos = baryU * t.v0.pos + baryV * t.v1.pos + baryW * t.v2.pos;

        avgColor += SampleTextureWorldSpace(surfacePos);
    }

    return avgColor;
}




ModSplat calcModSplat(int splatIndex, SplatData splat) {
    
    bool ignore = true;
    SplatLink currentSplat = LoadSplatLink(splatIndex);
    [unroll]
    for (int i = 0; i < 8; i++) {
        // Check if valid triangle
        int triangleId = currentSplat.triangleIds[i];
        float triangleWeight = currentSplat.triangleWeights[i];
        if (triangleId == -1 || triangleWeight <= 0) continue;

        if (any(LoadVertexPos1(triangleId).posMod) ||
            any(LoadVertexPos2(triangleId).posMod) ||
            any(LoadVertexPos3(triangleId).posMod)) {
            ignore = false;
        }
    }

    ModSplat m;
    if (ignore) {
        m.pos = splat.pos;
        m.scale = splat.scale;
        m.rot = splat.rot;
    } else {
        // Ensure numerical stability
        float maxScale = max(splat.scale.x, max(splat.scale.y, splat.scale.z));
        splat.scale = max(splat.scale, maxScale / 1000.0);

        Tetrahedron baseTetra = computeTetrahedronFromEllipsoid(splat.pos, splat.scale, splat.rot);
        Tetrahedron transformTetra;
        transformTetra.v0 = translatePoint(splatIndex, baseTetra.v0);
        transformTetra.v1 = translatePoint(splatIndex, baseTetra.v1);
        transformTetra.v2 = translatePoint(splatIndex, baseTetra.v2);
        transformTetra.v3 = translatePoint(splatIndex, baseTetra.v3);

        fitSteinerCircumellipsoid(transformTetra, m);
    }
    m.color = getModColor(splatIndex);

    return m;
}


[numthreads(GROUP_SIZE,1,1)]
void CSCalcDistances (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    uint origIdx = _SplatSortKeys[idx];

    bool ignore = true;
    [unroll]
    for (int i = 0; i < 8; i++) {
        // Check if valid triangle
        int triangleId = LoadSplatLink(origIdx).triangleIds[i];
        float triangleWeight = LoadSplatLink(origIdx).triangleWeights[i];
        if (triangleId == -1 || triangleWeight <= 0) continue;

        if (any(LoadVertexPos1(triangleId).posMod) ||
            any(LoadVertexPos2(triangleId).posMod) ||
            any(LoadVertexPos3(triangleId).posMod)) {
            ignore = false;
        }
    }

    float3 pos;
    if (ignore) {
        pos = LoadSplatPos(origIdx);
    } else {
        SplatData splat = LoadSplatData(origIdx);
        Tetrahedron baseTetra = computeTetrahedronFromEllipsoid(splat.pos, splat.scale, splat.rot);
        pos = translatePoint(origIdx, (baseTetra.v0 + baseTetra.v1 + baseTetra.v2 + baseTetra.v3) / 4.0);
    }

    pos = mul(_MatrixMV, float4(pos.xyz, 1)).xyz;

    _SplatSortDistances[idx] = FloatToSortableUint(pos.z);
}

RWStructuredBuffer<SplatViewData> _SplatViewData;

float _SplatScale;
float _SplatOpacityScale;
uint _SHOrder;
uint _SHOnly;

uint _SplatCutoutsCount;

#define SPLAT_CUTOUT_TYPE_ELLIPSOID 0
#define SPLAT_CUTOUT_TYPE_BOX 1

struct GaussianCutoutShaderData // match GaussianCutout.ShaderData in C#
{
    float4x4 mat;
    uint typeAndFlags;
};
StructuredBuffer<GaussianCutoutShaderData> _SplatCutouts;

RWByteAddressBuffer _SplatSelectedBits;
ByteAddressBuffer _SplatDeletedBits;
uint _SplatBitsValid;

void DecomposeCovariance(float3 cov2d, out float2 v1, out float2 v2)
{
    #if 0 // does not quite give the correct results?

    // https://jsfiddle.net/mattrossman/ehxmtgw6/
    // References:
    // - https://www.youtube.com/watch?v=e50Bj7jn9IQ
    // - https://en.wikipedia.org/wiki/Eigenvalue_algorithm#2%C3%972_matrices
    // - https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
    float a = cov2d.x;
    float b = cov2d.y;
    float d = cov2d.z;
    float det = a * d - b * b; // matrix is symmetric, so "c" is same as "b"
    float trace = a + d;

    float mean = 0.5 * trace;
    float dist = sqrt(mean * mean - det);

    float lambda1 = mean + dist; // 1st eigenvalue
    float lambda2 = mean - dist; // 2nd eigenvalue

    if (b == 0) {
        // https://twitter.com/the_ross_man/status/1706342719776551360
        if (a > d) v1 = float2(1, 0);
        else v1 = float2(0, 1);
    } else
        v1 = normalize(float2(b, d - lambda2));

    v1.y = -v1.y;
    // The 2nd eigenvector is just a 90 degree rotation of the first since Gaussian axes are orthogonal
    v2 = float2(v1.y, -v1.x);

    // scaling components
    v1 *= sqrt(lambda1);
    v2 *= sqrt(lambda2);

    float radius = 1.5;
    v1 *= radius;
    v2 *= radius;

    #else

    // same as in antimatter15/splat
    float diag1 = cov2d.x, diag2 = cov2d.z, offDiag = cov2d.y;
    float mid = 0.5f * (diag1 + diag2);
    float radius = length(float2((diag1 - diag2) / 2.0, offDiag));
    float lambda1 = mid + radius;
    float lambda2 = max(mid - radius, 0.1);
    float2 diagVec = normalize(float2(offDiag, lambda1 - diag1));
    diagVec.y = -diagVec.y;
    float maxSize = 4096.0;
    v1 = min(sqrt(2.0 * lambda1), maxSize) * diagVec;
    v2 = min(sqrt(2.0 * lambda2), maxSize) * float2(diagVec.y, -diagVec.x);

    #endif
}

bool IsSplatCut(float3 pos)
{
    bool finalCut = false;
    for (uint i = 0; i < _SplatCutoutsCount; ++i)
    {
        GaussianCutoutShaderData cutData = _SplatCutouts[i];
        uint type = cutData.typeAndFlags & 0xFF;
        if (type == 0xFF) // invalid/null cutout, ignore
            continue;
        bool invert = (cutData.typeAndFlags & 0xFF00) != 0;

        float3 cutoutPos = mul(cutData.mat, float4(pos, 1)).xyz;
        if (type == SPLAT_CUTOUT_TYPE_ELLIPSOID)
        {
            if (dot(cutoutPos, cutoutPos) <= 1) return invert;
        }
        if (type == SPLAT_CUTOUT_TYPE_BOX)
        {
            if (all(abs(cutoutPos) <= 1)) return invert;
        }
        finalCut |= !invert;
    }
    return finalCut;
}


[numthreads(GROUP_SIZE,1,1)]
void CSCalcViewData (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    SplatData splat = LoadSplatData(idx);
    SplatViewData view = (SplatViewData)0;

    ModSplat modSplat = calcModSplat(idx, splat);
    
    float3 centerWorldPos = mul(_MatrixObjectToWorld, float4(modSplat.pos ,1)).xyz;
    float4 centerClipPos = mul(_MatrixVP, float4(centerWorldPos, 1));
    half opacityScale = _SplatOpacityScale;
    float splatScale = _SplatScale;
   
    view.pos = centerClipPos;
    bool behindCam = centerClipPos.w <= 0;
    if (!behindCam)
    {
        float3x3 splatRotScaleMat = CalcMatrixFromRotationScale(modSplat.rot, modSplat.scale * splatScale);

        float3 cov3d0, cov3d1;
        CalcCovariance3D(splatRotScaleMat, cov3d0, cov3d1);

        float3 cov2d = CalcCovariance2D(modSplat.pos, cov3d0, cov3d1, _MatrixMV, _MatrixP, _VecScreenParams);
        
        DecomposeCovariance(cov2d, view.axis1, view.axis2);

        float3 worldViewDir = _VecWorldSpaceCameraPos.xyz - centerWorldPos;
        float3 objViewDir = mul((float3x3)_MatrixWorldToObject, worldViewDir);
        objViewDir = normalize(objViewDir);

        half4 col;
        col.rgb = ShadeSH(splat.sh, objViewDir, _SHOrder, _SHOnly != 0);
        col.a = min(splat.opacity * opacityScale, 65000);

        col = fullBg(col, modSplat.color);

        view.color.x = (f32tof16(col.r) << 16) | f32tof16(col.g);
        view.color.y = (f32tof16(col.b) << 16) | f32tof16(col.a);
    }
    
    _SplatViewData[idx] = view;
}


RWByteAddressBuffer _DstBuffer;
ByteAddressBuffer _SrcBuffer;
uint _BufferSize;

uint2 GetSplatIndicesFromWord(uint idx)
{
    uint idxStart = idx * 32;
    uint idxEnd = min(idxStart + 32, _SplatCount);
    return uint2(idxStart, idxEnd);
}

[numthreads(GROUP_SIZE,1,1)]
void CSUpdateEditData (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _BufferSize)
        return;

    uint valSel = _SplatSelectedBits.Load(idx * 4);
    uint valDel = _SplatDeletedBits.Load(idx * 4);
    valSel &= ~valDel; // don't count deleted splats as selected
    uint2 splatIndices = GetSplatIndicesFromWord(idx);

    // update selection bounds
    float3 bmin = 1.0e38;
    float3 bmax = -1.0e38;
    uint mask = 1;
    uint valCut = 0;
    for (uint sidx = splatIndices.x; sidx < splatIndices.y; ++sidx, mask <<= 1)
    {
        float3 spos = LoadSplatPos(sidx);
        // don't count cut splats as selected
        if (IsSplatCut(spos))
        {
            valSel &= ~mask;
            valCut |= mask;
        }
        if (valSel & mask)
        {
            bmin = min(bmin, spos);
            bmax = max(bmax, spos);
        }
    }
    valCut &= ~valDel; // don't count deleted splats as cut

    if (valSel != 0)
    {
        _DstBuffer.InterlockedMin(12, FloatToSortableUint(bmin.x));
        _DstBuffer.InterlockedMin(16, FloatToSortableUint(bmin.y));
        _DstBuffer.InterlockedMin(20, FloatToSortableUint(bmin.z));
        _DstBuffer.InterlockedMax(24, FloatToSortableUint(bmax.x));
        _DstBuffer.InterlockedMax(28, FloatToSortableUint(bmax.y));
        _DstBuffer.InterlockedMax(32, FloatToSortableUint(bmax.z));
    }
    uint sumSel = countbits(valSel);
    uint sumDel = countbits(valDel);
    uint sumCut = countbits(valCut);
    _DstBuffer.InterlockedAdd(0, sumSel);
    _DstBuffer.InterlockedAdd(4, sumDel);
    _DstBuffer.InterlockedAdd(8, sumCut);
}

[numthreads(1,1,1)]
void CSInitEditData (uint3 id : SV_DispatchThreadID)
{
    _DstBuffer.Store3(0, uint3(0,0,0)); // selected, deleted, cut counts
    uint initMin = FloatToSortableUint(1.0e38);
    uint initMax = FloatToSortableUint(-1.0e38);
    _DstBuffer.Store3(12, uint3(initMin, initMin, initMin));
    _DstBuffer.Store3(24, uint3(initMax, initMax, initMax));
}

[numthreads(GROUP_SIZE,1,1)]
void CSClearBuffer (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _BufferSize)
        return;
    _DstBuffer.Store(idx * 4, 0);
}

[numthreads(GROUP_SIZE,1,1)]
void CSInvertSelection (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _BufferSize)
        return;
    uint v = _DstBuffer.Load(idx * 4);
    v = ~v;

    // do not select splats that are cut
    uint2 splatIndices = GetSplatIndicesFromWord(idx);
    uint mask = 1;
    for (uint sidx = splatIndices.x; sidx < splatIndices.y; ++sidx, mask <<= 1)
    {
        float3 spos = LoadSplatPos(sidx);
        if (IsSplatCut(spos))
            v &= ~mask;
    }

    _DstBuffer.Store(idx * 4, v);
}

[numthreads(GROUP_SIZE,1,1)]
void CSSelectAll (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _BufferSize)
        return;
    uint v = ~0;

    // do not select splats that are cut
    uint2 splatIndices = GetSplatIndicesFromWord(idx);
    uint mask = 1;
    for (uint sidx = splatIndices.x; sidx < splatIndices.y; ++sidx, mask <<= 1)
    {
        float3 spos = LoadSplatPos(sidx);
        if (IsSplatCut(spos))
            v &= ~mask;
    }

    _DstBuffer.Store(idx * 4, v);
}


[numthreads(GROUP_SIZE,1,1)]
void CSOrBuffers (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _BufferSize)
        return;
    uint a = _SrcBuffer.Load(idx * 4);
    uint b = _DstBuffer.Load(idx * 4);
    _DstBuffer.Store(idx * 4, a | b);
}

float4 _SelectionRect;

[numthreads(GROUP_SIZE,1,1)]
void CSSelectionUpdate (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    float3 pos = LoadSplatPos(idx);
    if (IsSplatCut(pos))
        return;

    float3 centerWorldPos = mul(_MatrixObjectToWorld, float4(pos,1)).xyz;
    float4 centerClipPos = mul(_MatrixVP, float4(centerWorldPos, 1));
    bool behindCam = centerClipPos.w <= 0;
    if (behindCam)
        return;

    float2 pixelPos = (centerClipPos.xy / centerClipPos.w * float2(0.5, -0.5) + 0.5) * _VecScreenParams.xy;
    if (pixelPos.x < _SelectionRect.x || pixelPos.x > _SelectionRect.z ||
        pixelPos.y < _SelectionRect.y || pixelPos.y > _SelectionRect.w)
    {
        return;
    }
    uint wordIdx = idx / 32;
    uint bitIdx = idx & 31;
    if (_SelectionMode)
        _SplatSelectedBits.InterlockedOr(wordIdx * 4, 1u << bitIdx); // +
    else
        _SplatSelectedBits.InterlockedAnd(wordIdx * 4, ~(1u << bitIdx)); // -
}

float3 _SelectionDelta;

bool IsSplatSelected(uint idx)
{
    uint wordIdx = idx / 32;
    uint bitIdx = idx & 31;
    uint selVal = _SplatSelectedBits.Load(wordIdx * 4);
    return (selVal & (1 << bitIdx)) != 0;
}

[numthreads(GROUP_SIZE,1,1)]
void CSTranslateSelection (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;
    if (!IsSplatSelected(idx))
        return;

    uint fmt = _SplatFormat & 0xFF;
    if (_SplatChunkCount == 0 && fmt == VECTOR_FMT_32F)
    {
        uint stride = 12;
        float3 pos = asfloat(_SplatPos.Load3(idx * stride));
        pos += _SelectionDelta;
        _SplatPos.Store3(idx * stride, asuint(pos));
    }
}

float3 _SelectionCenter;
float4 _SelectionDeltaRot;
ByteAddressBuffer _SplatPosMouseDown;
ByteAddressBuffer _SplatOtherMouseDown;

[numthreads(GROUP_SIZE,1,1)]
void CSRotateSelection (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;
    if (!IsSplatSelected(idx))
        return;

    uint posFmt = _SplatFormat & 0xFF;
    if (_SplatChunkCount == 0 && posFmt == VECTOR_FMT_32F)
    {
        uint posStride = 12;
        float3 pos = asfloat(_SplatPosMouseDown.Load3(idx * posStride));
        pos -= _SelectionCenter;
        pos = mul(_MatrixObjectToWorld, float4(pos,1)).xyz;
        pos = QuatRotateVector(pos, _SelectionDeltaRot);
        pos = mul(_MatrixWorldToObject, float4(pos,1)).xyz;
        pos += _SelectionCenter;
        _SplatPos.Store3(idx * posStride, asuint(pos));
    }

    uint scaleFmt = (_SplatFormat >> 8) & 0xFF;
    uint shFormat = (_SplatFormat >> 16) & 0xFF;
    if (_SplatChunkCount == 0 && scaleFmt == VECTOR_FMT_32F && shFormat == VECTOR_FMT_32F)
    {
        uint otherStride = 4 + 12;
        uint rotVal = _SplatOtherMouseDown.Load(idx * otherStride);
        float4 rot = DecodeRotation(DecodePacked_10_10_10_2(rotVal));

        //@TODO: correct rotation
        rot = QuatMul(rot, _SelectionDeltaRot);

        rotVal = EncodeQuatToNorm10(PackSmallest3Rotation(rot));
        _SplatOther.Store(idx * otherStride, rotVal);
    }

    //@TODO: rotate SHs
}

//@TODO: maybe scale the splat scale itself too?
[numthreads(GROUP_SIZE,1,1)]
void CSScaleSelection (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;
    if (!IsSplatSelected(idx))
        return;

    uint fmt = _SplatFormat & 0xFF;
    if (_SplatChunkCount == 0 && fmt == VECTOR_FMT_32F)
    {
        uint stride = 12;
        float3 pos = asfloat(_SplatPosMouseDown.Load3(idx * stride));
        pos -= _SelectionCenter;
        pos = mul(_MatrixObjectToWorld, float4(pos,1)).xyz;
        pos *= _SelectionDelta;
        pos = mul(_MatrixWorldToObject, float4(pos,1)).xyz;
        pos += _SelectionCenter;
        _SplatPos.Store3(idx * stride, asuint(pos));
    }
}

struct ExportSplatData
{
    float3 pos;
    float3 nor;
    float3 dc0;
    float4 shR14; float4 shR58; float4 shR9C; float3 shRDF;
    float4 shG14; float4 shG58; float4 shG9C; float3 shGDF;
    float4 shB14; float4 shB58; float4 shB9C; float3 shBDF;
    float opacity;
    float3 scale;
    float4 rot;
};
RWStructuredBuffer<ExportSplatData> _ExportBuffer;

float3 ColorToSH0(float3 col)
{
    return (col - 0.5) / 0.2820948;
}
float InvSigmoid(float v)
{
    return log(v / max(1 - v, 1.0e-6));
}

// SH rotation
#include "SphericalHarmonics.hlsl"

void RotateSH(inout SplatSHData sh, float3x3 rot)
{
    float3 shin[16];
    float3 shout[16];
    shin[0] = sh.col;
    shin[1] = sh.sh1;
    shin[2] = sh.sh2;
    shin[3] = sh.sh3;
    shin[4] = sh.sh4;
    shin[5] = sh.sh5;
    shin[6] = sh.sh6;
    shin[7] = sh.sh7;
    shin[8] = sh.sh8;
    shin[9] = sh.sh9;
    shin[10] = sh.sh10;
    shin[11] = sh.sh11;
    shin[12] = sh.sh12;
    shin[13] = sh.sh13;
    shin[14] = sh.sh14;
    shin[15] = sh.sh15;
    RotateSH(rot, 4, shin, shout);
    sh.col = shout[0];
    sh.sh1 = shout[1];
    sh.sh2 = shout[2];
    sh.sh3 = shout[3];
    sh.sh4 = shout[4];
    sh.sh5 = shout[5];
    sh.sh6 = shout[6];
    sh.sh7 = shout[7];
    sh.sh8 = shout[8];
    sh.sh9 = shout[9];
    sh.sh10 = shout[10];
    sh.sh11 = shout[11];
    sh.sh12 = shout[12];
    sh.sh13 = shout[13];
    sh.sh14 = shout[14];
    sh.sh15 = shout[15];
}

float3x3 CalcSHRotMatrix(float4x4 objToWorld)
{
    float3x3 m = (float3x3)objToWorld;
    float sx = length(float3(m[0][0], m[0][1], m[0][2]));
    float sy = length(float3(m[1][0], m[1][1], m[1][2]));
    float sz = length(float3(m[2][0], m[2][1], m[2][2]));

    float invSX = 1.0 / sx;
    float invSY = 1.0 / sy;
    float invSZ = 1.0 / sz;

    m[0][0] *= invSX;
    m[0][1] *= invSX;
    m[0][2] *= invSX;
    m[1][0] *= invSY;
    m[1][1] *= invSY;
    m[1][2] *= invSY;
    m[2][0] *= invSZ;
    m[2][1] *= invSZ;
    m[2][2] *= invSZ;
    return m;
}


float4 _ExportTransformRotation;
float3 _ExportTransformScale;
uint _ExportTransformFlags;

[numthreads(GROUP_SIZE,1,1)]
void CSExportData (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;
    SplatData src = LoadSplatData(idx);

    bool isCut = IsSplatCut(src.pos);

    // transform splat by matrix, if needed
    if (_ExportTransformFlags != 0)
    {
        src.pos = mul(_MatrixObjectToWorld, float4(src.pos,1)).xyz;

        // note: this only handles axis flips from scale, not any arbitrary scaling
        if (_ExportTransformScale.x < 0)
            src.rot.yz = -src.rot.yz;
        if (_ExportTransformScale.y < 0)
            src.rot.xz = -src.rot.xz;
        if (_ExportTransformScale.z < 0)
            src.rot.xy = -src.rot.xy;
        src.rot = QuatMul(_ExportTransformRotation, src.rot);
        src.scale *= abs(_ExportTransformScale);

        float3x3 shRot = CalcSHRotMatrix(_MatrixObjectToWorld);
        RotateSH(src.sh, shRot);
    }

    ExportSplatData dst;
    dst.pos = src.pos;
    dst.nor = 0;
    dst.dc0 = ColorToSH0(src.sh.col);
    
    dst.shR14 = float4(src.sh.sh1.r, src.sh.sh2.r, src.sh.sh3.r, src.sh.sh4.r);
    dst.shR58 = float4(src.sh.sh5.r, src.sh.sh6.r, src.sh.sh7.r, src.sh.sh8.r);
    dst.shR9C = float4(src.sh.sh9.r, src.sh.sh10.r, src.sh.sh11.r, src.sh.sh12.r);
    dst.shRDF = float3(src.sh.sh13.r, src.sh.sh14.r, src.sh.sh15.r);
    
    dst.shG14 = float4(src.sh.sh1.g, src.sh.sh2.g, src.sh.sh3.g, src.sh.sh4.g);
    dst.shG58 = float4(src.sh.sh5.g, src.sh.sh6.g, src.sh.sh7.g, src.sh.sh8.g);
    dst.shG9C = float4(src.sh.sh9.g, src.sh.sh10.g, src.sh.sh11.g, src.sh.sh12.g);
    dst.shGDF = float3(src.sh.sh13.g, src.sh.sh14.g, src.sh.sh15.g);
    
    dst.shB14 = float4(src.sh.sh1.b, src.sh.sh2.b, src.sh.sh3.b, src.sh.sh4.b);
    dst.shB58 = float4(src.sh.sh5.b, src.sh.sh6.b, src.sh.sh7.b, src.sh.sh8.b);
    dst.shB9C = float4(src.sh.sh9.b, src.sh.sh10.b, src.sh.sh11.b, src.sh.sh12.b);
    dst.shBDF = float3(src.sh.sh13.b, src.sh.sh14.b, src.sh.sh15.b);
    
    dst.opacity = InvSigmoid(src.opacity);
    dst.scale = log(src.scale);
    dst.rot = src.rot.wxyz;

    if (isCut)
        dst.nor = 1; // mark as skipped for export
    
    _ExportBuffer[idx] = dst;
}

RWByteAddressBuffer _CopyDstPos;
RWByteAddressBuffer _CopyDstOther;
RWByteAddressBuffer _CopyDstSH;
RWByteAddressBuffer _CopyDstEditDeleted;
RWTexture2D<float4> _CopyDstColor;
uint _CopyDstSize, _CopySrcStartIndex, _CopyDstStartIndex, _CopyCount;

float4x4 _CopyTransformMatrix;
float4 _CopyTransformRotation;
float3 _CopyTransformScale;

[numthreads(GROUP_SIZE,1,1)]
void CSCopySplats (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _CopyCount)
        return;
    uint srcIdx = _CopySrcStartIndex + idx;
    uint dstIdx = _CopyDstStartIndex + idx;
    if (srcIdx >= _SplatCount || dstIdx >= _CopyDstSize)
        return;

    SplatData src = LoadSplatData(idx);

    // transform the splat
    src.pos = mul(_CopyTransformMatrix, float4(src.pos,1)).xyz;
    // note: this only handles axis flips from scale, not any arbitrary scaling
    if (_CopyTransformScale.x < 0)
        src.rot.yz = -src.rot.yz;
    if (_CopyTransformScale.y < 0)
        src.rot.xz = -src.rot.xz;
    if (_CopyTransformScale.z < 0)
        src.rot.xy = -src.rot.xy;
    src.rot = QuatMul(_CopyTransformRotation, src.rot);
    src.scale *= abs(_CopyTransformScale);

    float3x3 shRot = CalcSHRotMatrix(_CopyTransformMatrix);
    RotateSH(src.sh, shRot);

    // output data into destination:
    // pos
    uint posStride = 12;
    _CopyDstPos.Store3(dstIdx * posStride, asuint(src.pos));
    // rot + scale
    uint otherStride = 4 + 12;
    uint rotVal = EncodeQuatToNorm10(PackSmallest3Rotation(src.rot));
    _CopyDstOther.Store4(dstIdx * otherStride, uint4(
        rotVal,
        asuint(src.scale.x),
        asuint(src.scale.y),
        asuint(src.scale.z)));
    // color
    uint3 pixelIndex = SplatIndexToPixelIndex(dstIdx);
    _CopyDstColor[pixelIndex.xy] = float4(src.sh.col, src.opacity);

    // SH
    uint shStride = 192; // 15*3 fp32, rounded up to multiple of 16
    uint shOffset = dstIdx * shStride;
    _CopyDstSH.Store3(shOffset + 12 * 0, asuint(src.sh.sh1));
    _CopyDstSH.Store3(shOffset + 12 * 1, asuint(src.sh.sh2));
    _CopyDstSH.Store3(shOffset + 12 * 2, asuint(src.sh.sh3));
    _CopyDstSH.Store3(shOffset + 12 * 3, asuint(src.sh.sh4));
    _CopyDstSH.Store3(shOffset + 12 * 4, asuint(src.sh.sh5));
    _CopyDstSH.Store3(shOffset + 12 * 5, asuint(src.sh.sh6));
    _CopyDstSH.Store3(shOffset + 12 * 6, asuint(src.sh.sh7));
    _CopyDstSH.Store3(shOffset + 12 * 7, asuint(src.sh.sh8));
    _CopyDstSH.Store3(shOffset + 12 * 8, asuint(src.sh.sh9));
    _CopyDstSH.Store3(shOffset + 12 * 9, asuint(src.sh.sh10));
    _CopyDstSH.Store3(shOffset + 12 * 10, asuint(src.sh.sh11));
    _CopyDstSH.Store3(shOffset + 12 * 11, asuint(src.sh.sh12));
    _CopyDstSH.Store3(shOffset + 12 * 12, asuint(src.sh.sh13));
    _CopyDstSH.Store3(shOffset + 12 * 13, asuint(src.sh.sh14));
    _CopyDstSH.Store3(shOffset + 12 * 14, asuint(src.sh.sh15));

    // deleted bits
    uint srcWordIdx = srcIdx / 32;
    uint srcBitIdx = srcIdx & 31;
    if (_SplatDeletedBits.Load(srcWordIdx * 4) & (1u << srcBitIdx))
    {
        uint dstWordIdx = dstIdx / 32;
        uint dstBitIdx = dstIdx & 31;
        _CopyDstEditDeleted.InterlockedOr(dstWordIdx * 4, 1u << dstBitIdx);
    }
}
