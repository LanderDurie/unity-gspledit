ModSplat calcModSplat(TriangleSet ts, SplatData splat, float triangleX, float triangleY) {
    float3 baseTetrahedron[4];
    float3 modTetrahedron[4];

    baseTetrahedron[0] = ts.p0.pos;
    baseTetrahedron[1] = ts.p1.pos;
    baseTetrahedron[2] = ts.p2.pos;
    float3 baseTetrahedronNormal = calculateTriangleNormal(baseTetrahedron[0], baseTetrahedron[1], baseTetrahedron[2]);
    float baseTetrahedronHeight = (length(baseTetrahedron[1] - baseTetrahedron[0]) + length(baseTetrahedron[2] - baseTetrahedron[0])) / 2;
    baseTetrahedron[3] = (baseTetrahedron[0] + baseTetrahedron[1] + baseTetrahedron[2]) / 3 + baseTetrahedronNormal * 0.1;

    modTetrahedron[0] = ts.p0.pos + ts.p0.posMod;
    modTetrahedron[1] = ts.p1.pos + ts.p1.posMod;
    modTetrahedron[2] = ts.p2.pos + ts.p2.posMod;
    float3 modTetrahedronNormal = calculateTriangleNormal(modTetrahedron[0], modTetrahedron[1], modTetrahedron[2]);
    float modTetrahedronHeight = (length(modTetrahedron[1] - modTetrahedron[0]) + length(modTetrahedron[2] - modTetrahedron[0])) / 2;
    modTetrahedron[3] = (modTetrahedron[0] + modTetrahedron[1] + modTetrahedron[2]) / 3 + baseTetrahedronNormal * 0.1;



    // Calculate centroids
    float3 baseCentroid = (baseTetrahedron[0] + baseTetrahedron[1] + baseTetrahedron[2] + baseTetrahedron[3]) / 4.0;
    float3 modCentroid = (modTetrahedron[0] + modTetrahedron[1] + modTetrahedron[2] + modTetrahedron[3]) / 4.0;

    // Translation
    float3 translation = modCentroid - baseCentroid;
    float4x4 translationMatrix = float4x4(
        1.0, 0.0, 0.0, translation.x,
        0.0, 1.0, 0.0, translation.y,
        0.0, 0.0, 1.0, translation.z,
        0.0, 0.0, 0.0, 1.0
    );

    // Rotation
    float3 rotationAxis = normalize(cross(baseTetrahedronNormal, modTetrahedronNormal));
    float rotationAngle = acos(dot(normalize(baseTetrahedronNormal), normalize(modTetrahedronNormal)));

    float c = cos(rotationAngle);
    float s = sin(rotationAngle);
    float t = 1.0 - c;

    float4x4 rotationMatrix = float4x4(
        t * rotationAxis.x * rotationAxis.x + c,         t * rotationAxis.x * rotationAxis.y - s * rotationAxis.z, t * rotationAxis.x * rotationAxis.z + s * rotationAxis.y, 0.0,
        t * rotationAxis.x * rotationAxis.y + s * rotationAxis.z, t * rotationAxis.y * rotationAxis.y + c,         t * rotationAxis.y * rotationAxis.z - s * rotationAxis.x, 0.0,
        t * rotationAxis.x * rotationAxis.z - s * rotationAxis.y, t * rotationAxis.y * rotationAxis.z + s * rotationAxis.x, t * rotationAxis.z * rotationAxis.z + c,         0.0,
        0.0,                                           0.0,                                           0.0,                                           1.0
    );

    // Compute base dimensions
    float3 baseX = baseTetrahedron[1] - baseTetrahedron[0];
    float3 baseY = baseTetrahedron[2] - baseTetrahedron[0];
    float3 baseZ = baseTetrahedron[3] - baseCentroid;

    float baseWidth = length(baseX);
    float baseDepth = length(baseY);
    float baseHeight = length(baseZ);

    // Compute modified dimensions
    float3 modX = modTetrahedron[1] - modTetrahedron[0];
    float3 modY = modTetrahedron[2] - modTetrahedron[0];
    float3 modZ = modTetrahedron[3] - modCentroid;

    float modWidth = length(modX);
    float modDepth = length(modY);
    float modHeight = length(modZ);

    // Non-uniform scale factors
    float scaleX = modWidth / baseWidth;
    float scaleY = modDepth / baseDepth;
    float scaleZ = modHeight / baseHeight;

    // Construct the non-uniform scale matrix
    float4x4 scaleMatrix = float4x4(
        scaleX, 0.0,   0.0,   0.0,
        0.0,   scaleY, 0.0,   0.0,
        0.0,   0.0,   scaleZ, 0.0,
        0.0,   0.0,   0.0,   1.0
    );




    float3 newPos = mul(translationMatrix, float4(splat.pos, 1.0));
    float3 newScale = float3(scaleX, scaleY, scaleZ);
    float4 newRotation = (matrixToQuaternion(rotationMatrix));

    // Populate result
    ModSplat result;
    result.pos = newPos;
    result.scale = newScale;
    result.rot = newRotation;

    return result;
}