#pragma kernel OpacityContributions
#include "../../../../Gaussian/Compute/GaussianSplatting.hlsl"
#include "../../../Compute/LinkUtilities.hlsl"
#include "../../../../Gaussian/Compute/SamplePoints.hlsl"
#include "./Utils.hlsl"

struct Triangle {
    int v0;
    int v1;
    int v2;
};

RWStructuredBuffer<float3> _VertexBasePos;
RWStructuredBuffer<Triangle> _MeshIndices;
uint _IndexCount;
uint _SplatCount;
float _GlobalSigma;
static const float MAX_DISTANCE = 1e30f;

[numthreads(128, 1, 1)]
void OpacityContributions(uint3 id : SV_DispatchThreadID) {
    uint splatIndex = id.x;
    if (splatIndex >= _SplatCount) return;
    
    SplatData splat = LoadSplatData(splatIndex);
    Tetrahedron tetra = computeTetrahedronFromEllipsoid(splat.pos, splat.scale, splat.rot, 100);
    
    float3 tetraVertices[4];
    tetraVertices[0] = tetra.v0;
    tetraVertices[1] = tetra.v1;
    tetraVertices[2] = tetra.v2;
    tetraVertices[3] = tetra.v3;
    
    // For each vertex, store the 2 best triangles
    float vertexMinDistances[4][2] = {
        { MAX_DISTANCE, MAX_DISTANCE },
        { MAX_DISTANCE, MAX_DISTANCE },
        { MAX_DISTANCE, MAX_DISTANCE },
        { MAX_DISTANCE, MAX_DISTANCE }
    };
    int vertexMinIndices[4][2] = {
        { -1, -1 },
        { -1, -1 },
        { -1, -1 },
        { -1, -1 }
    };
    
    // First pass: find closest triangles for each vertex
    [loop]
    for (uint i = 0; i < _IndexCount; i++) {
        Triangle t = _MeshIndices[i];
        float3 p1 = _VertexBasePos[t.v0];
        float3 p2 = _VertexBasePos[t.v1];
        float3 p3 = _VertexBasePos[t.v2];
        float baseDist = length(splat.pos - ClosestPoint(splat.pos, p1, p2, p3));

        // Check each tetrahedron vertex
        for (uint v = 0; v < 4; v++) {
            // Calculate distance from vertex to triangle
            float distance = length(tetraVertices[v] - ClosestPoint(tetraVertices[v], p1, p2, p3));
            distance = lerp(distance, baseDist, 0.7);

            // Check if this triangle is already assigned to another vertex
            bool alreadyAssigned = false;
            for (uint otherV = 0; otherV < 4; otherV++) {
                if (otherV == v) continue;  // Skip the current vertex
                
                // Check if this triangle index is already assigned to another vertex
                for (uint j = 0; j < 2; j++) {
                    if (vertexMinIndices[otherV][j] == (int)i) {
                        alreadyAssigned = true;
                        break;
                    }
                }
                if (alreadyAssigned) break;
            }
            
            // Skip if already assigned to another vertex
            if (alreadyAssigned) continue;
            
            // Check if this triangle is better than current choices for this vertex
            for (uint j = 0; j < 2; j++) {
                if (distance < vertexMinDistances[v][j]) {
                    // Shift values if needed
                    if (j == 0) {
                        vertexMinDistances[v][1] = vertexMinDistances[v][0];
                        vertexMinIndices[v][1] = vertexMinIndices[v][0];
                    }
                    
                    // Insert the new triangle
                    vertexMinDistances[v][j] = distance;
                    vertexMinIndices[v][j] = i;
                    break;
                }
            }
        }
    }
    
    // Convert vertex-based arrays to the flat arrays needed for output
    float minDistances[LINK_COUNT];
    int minIndices[LINK_COUNT];
    
    for (uint v = 0; v < 4; v++) {
        uint baseSlot = v * 2;
        
        // Assign the two links for this vertex
        minDistances[baseSlot] = vertexMinDistances[v][0];
        minIndices[baseSlot] = vertexMinIndices[v][0];
        
        minDistances[baseSlot + 1] = vertexMinDistances[v][1];
        minIndices[baseSlot + 1] = vertexMinIndices[v][1];
    }
    
    // Calculate total distance for normalization
    float totalDist = 0.0;
    for (uint j = 0; j < LINK_COUNT; j++) {
        if (minIndices[j] >= 0 && minDistances[j] < MAX_DISTANCE) {
            totalDist += minDistances[j];
        }
    }
    
    // Calculate weights and store results
    SplatLink splatLinks;
    float sigmaSquared = _GlobalSigma * _GlobalSigma;
    float threshold = 0.00001;
    
    [unroll]
    for (uint k = 0; k < LINK_COUNT; k++) {
        float weight = (totalDist > 0.0) ? (1.0 - (minDistances[k] / totalDist)) : 0.0;
        splatLinks.triangleIds[k] = (minIndices[k] >= 0 && weight > threshold) ? minIndices[k] : -1;
        splatLinks.triangleWeights[k] = (minIndices[k] >= 0 && weight > threshold) ? weight : 0;
        
        // Store the barycentric coordinates (currently not utilized)
        splatLinks.triangleX[k] = 0;
        splatLinks.triangleY[k] = 0;
    }
    
    SetSplatLink(splatIndex, splatLinks);
}