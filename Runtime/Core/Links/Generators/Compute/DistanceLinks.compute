#pragma kernel OpacityContributions
#include "../../../Gaussian/Compute/GaussianSplatting.hlsl"

struct VertexProperties {
    float3 pos;          // 12 bytes (3 * 4)
    float3 normal;       // 12 bytes (3 * 4)
    uint colorIds[4];         // 16 bytes (4 * 4)
    float3 posMod;       // 12 bytes (3 * 4)
    float4 rotMod;       // 16 bytes (4 * 4)
    float3 scaleMod;     // 12 bytes (3 * 4)
    uint colorModIds[4]; // 48 bytes (4 * 12)
    // Total size: 128 bytes
};

struct EdgeProperties {
    int vertexId1;
    int vertexId2;
};

struct SplatLinks {
    int edgeIds[8];
    float edgeWeights[8];
    float edgeT[8];
};

RWStructuredBuffer<VertexProperties> _VertexProps;
RWStructuredBuffer<EdgeProperties> _EdgeProps;
RWStructuredBuffer<SplatLinks> _SplatLinkBuffer;
uint _SplatCount;
uint _VertexCount;
uint _EdgeCount;
static const float MAX_DISTANCE = 1e30f;
static const float MIN_VERTEX_SEPARATION = 0.01f; // Adjust this threshold as needed

// Helper function to check if an index is already in the list
bool IsIndexPresent(int newIndex, int existingIndices[8]) {
    for (int i = 0; i < 4; i++) {
        if (existingIndices[i] == newIndex) {
            return true;
        }
    }
    return false;
}

// Function to convert a 3x3 matrix to a 4x4 matrix
float4x4 Convert3x3To4x4(float3x3 mat3x3)
{
    return float4x4(
        float4(mat3x3[0], 0.0f),
        float4(mat3x3[1], 0.0f),
        float4(mat3x3[2], 0.0f),
        float4(0.0f, 0.0f, 0.0f, 1.0f)
    );
}

// Function to convert a quaternion to a 4x4 rotation matrix
float4x4 quatToMatrix(float4 quat)
{
    float3x3 rotationMat = float3x3(
        1.0f - 2.0f * (quat.y * quat.y + quat.z * quat.z),  2.0f * (quat.x * quat.y - quat.w * quat.z),  2.0f * (quat.x * quat.z + quat.w * quat.y),
        2.0f * (quat.x * quat.y + quat.w * quat.z),  1.0f - 2.0f * (quat.x * quat.x + quat.z * quat.z),  2.0f * (quat.y * quat.z - quat.w * quat.x),
        2.0f * (quat.x * quat.z - quat.w * quat.y),  2.0f * (quat.y * quat.z + quat.w * quat.x),  1.0f - 2.0f * (quat.x * quat.x + quat.y * quat.y)
    );
    return Convert3x3To4x4(rotationMat);
}

float3 mahalanobis_transform(float3 pos, SplatData splat) {
    // First translate to local space
    pos -= splat.pos;
    float4x4 rotationMatrix = quatToMatrix(splat.rot);
    float4x4 inverseRotation = transpose(rotationMatrix);
    pos = mul(inverseRotation, float4(pos, 0.0)).xyz;
    pos /= splat.scale;
    return pos;
}

float2 dist(float3 p1, float3 p2, float3 p3) {
    float3 edge = p2 - p1;
    float3 toPoint = p3 - p1;
    
    float edgeLengthSquared = dot(edge, edge);
    float t = dot(toPoint, edge) / max(edgeLengthSquared, 1e-6f); // Prevent division by zero
    
    t = clamp(t, 0.0, 1.0);
    
    float3 closestPoint = p1 + t * edge;
    float distance = length(p3 - closestPoint);
    
    return float2(distance, t);
}


[numthreads(128, 1, 1)]
void OpacityContributions(uint3 id : SV_DispatchThreadID) {
    uint splatIndex = id.x;
    if (splatIndex >= _SplatCount) return;

    SplatData splat = LoadSplatData(splatIndex);

    float minDistances[8] = { MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE };
    float minT[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    int minIndices[8] = { -1, -1, -1, -1, -1, -1, -1, -1 };
    int currentValidCount = 0;

    [loop]
    for (uint i = 0; i < _EdgeCount; i++) {


        float2 distance = dist(_VertexProps[_EdgeProps[i].vertexId1].pos, 
        _VertexProps[_EdgeProps[i].vertexId2].pos, 
        splat.pos);

        float3 pos1 = (_VertexProps[_EdgeProps[i].vertexId1].pos);
        float3 pos2 = (_VertexProps[_EdgeProps[i].vertexId2].pos);
        float2 d = dist(pos1, pos2, splat.pos);

        // Insert the new distance and index into the sorted list
        for (int j = 0; j < 8; j++) {
            if (d.x < minDistances[j]) {
                // Shift existing values down
                for (int k = 7; k > j; k--) {
                    minDistances[k] = minDistances[k - 1];
                    minIndices[k] = minIndices[k - 1];
                    minT[k] = minT[k - 1];
                }

                // Insert the new edge
                minDistances[j] = d.x;
                minIndices[j] = i;
                minT[j] = d.y;

                currentValidCount = min(currentValidCount + 1, 8);
                break;
            }
        }
    }

    // Calculate weights and store results
    SplatLinks splatLinks;
    float totalWeight = 0.0f;
    float sigma = 1.0f; // Adjust sigma as needed
    float sigmaSquared = sigma * sigma;
    bool found = false;

    [unroll]
    for (int j = 0; j < 8; j++) {
        float weight = exp(-minDistances[j] * minDistances[j] / (2.0f * sigmaSquared));
        
        if (weight > 0.0000001) {
            found = true;
            splatLinks.edgeIds[j] = minIndices[j];
            splatLinks.edgeWeights[j] = weight;
            totalWeight += weight;
            splatLinks.edgeT[j] = minT[j];
        } else {
            splatLinks.edgeIds[j] = -1;
            splatLinks.edgeWeights[j] = 0;
            splatLinks.edgeT[j] = 0;
        }
    }

    if (found) {
        // Second pass: normalize weights
        [unroll]
        for (int k = 0; k < 8; k++) {
            splatLinks.edgeWeights[k] /= totalWeight;
        }
    }

    _SplatLinkBuffer[splatIndex] = splatLinks;
}

// [numthreads(1216, 1, 1)]
// void OpacityContributions(uint3 id : SV_DispatchThreadID)
// {
//     uint splatIndex = id.x;
//     if (splatIndex >= _SplatCount) return;

//     SplatData splat = LoadSplatData(splatIndex);

//     float minDistances[16] = { MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE };
//     int minIndices[16] = { -1, -1, -1, -1, -1, -1, -1, -1 };
//     int currentValidCount = 0;

//     [loop]
//     for (uint i = 0; i < _VertexCount; i++) {
//         VertexProperties vertex = _VertexProps[i];

//         // Skip if this vertex is already in our list
//         if (IsIndexPresent(i, minIndices)) {
//             continue;
//         }

//         float3 transformedPos = splat.pos - vertex.pos;
//         float distanceSquared = dot(transformedPos, transformedPos);

//         // Insert the new distance and index into the sorted list of 16 closest vertices
//         for (int j = 0; j < 16; j++) {
//             if (distanceSquared < minDistances[j]) {
//                 // Shift existing values down
//                 for (int k = 7; k > j; k--) {
//                     minDistances[k] = minDistances[k - 1];
//                     minIndices[k] = minIndices[k - 1];
//                 }
//                 minDistances[j] = distanceSquared;
//                 minIndices[j] = i;
//                 currentValidCount = min(currentValidCount + 1, 16);
//                 break;
//             }
//         }
//     }

//     // // TODO: mahalanobis distance

//     // Calculate weights and store results
//     SplatLinks splatLinks;
//     float totalWeight = 0.0f;
//     float sigma = 0.01f; // Adjust sigma as needed
//     float sigmaSquared = sigma * sigma;

//     [unroll]
//     for (int j = 0; j < 16; j++) {
//         splatLinks.edgeIds[j] = minIndices[j];
//         float weight = exp(-minDistances[j] * minDistances[j] / (2.0f * sigmaSquared));
//         totalWeight += weight;
//         splatLinks.edgeWeights[j] = weight;
//         splatLinks.edgeWeights[j] = 0.0f;
//     }

//     // Normalize weights
//     [unroll]
//     for (int k = 0; k < 16; k++) {
//         splatLinks.edgeWeights[k] /= totalWeight;
//     }

//     _SplatLinkBuffer[splatIndex] = splatLinks;
// }
