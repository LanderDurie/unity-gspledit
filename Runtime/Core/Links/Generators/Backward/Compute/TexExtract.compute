// TriangleRasterization.compute
#pragma kernel RasterizeTriangle
#pragma kernel DrawEdges
#pragma kernel ClearTexture

// Input data
Texture2D<float4> _InputTexture;
RWTexture2D<float4> _OutputTexture;
int _TextureSize;
SamplerState sampler_linear_clamp; 
// Triangle data buffer structure:
// [0-8]: worldA, worldB, worldC (3 floats each)
// [9-14]: uvA, uvB, uvC (2 floats each)
// [15-17]: cameraPos (3 floats)
// [18-20]: faceNormal (3 floats)
// [21-36]: projectionMatrix (16 floats)
// [37-52]: viewMatrix (16 floats)
StructuredBuffer<float> _TriangleData;

// Edge drawing properties
float4 _EdgeColor;
int _EdgeThickness;
bool _DrawEdges;

// Helper function to extract a Vector3 from the triangle data
float3 GetVector3(StructuredBuffer<float> buffer, uint startIndex)
{
    return float3(buffer[startIndex], buffer[startIndex + 1], buffer[startIndex + 2]);
}

// Helper function to extract a Vector2 from the triangle data
float2 GetVector2(StructuredBuffer<float> buffer, uint startIndex)
{
    return float2(buffer[startIndex], buffer[startIndex + 1]);
}

// Helper function to extract a Matrix4x4 from the triangle data
float4x4 GetMatrix4x4(StructuredBuffer<float> buffer, uint startIndex)
{
    float4x4 m;
    
    for (int row = 0; row < 4; row++)
    {
        for (int col = 0; col < 4; col++)
        {
            m[row][col] = buffer[startIndex + row * 4 + col];
        }
    }
    
    return m;
}

// Helper function to transform a world position to NDC space
float2 WorldToNDC(float3 worldPos, float4x4 viewMatrix, float4x4 projMatrix)
{
    // Transform to view space
    float4 viewPos = mul(viewMatrix, float4(worldPos, 1.0));
    
    // Transform to clip space
    float4 clipPos = mul(projMatrix, viewPos);
    
    // Perspective division to get NDC
    float2 ndcPos = clipPos.xy / clipPos.w;
    
    return ndcPos;
}

// Helper function to compute barycentric coordinates
bool BarycentricCoordinates(float2 p, float2 a, float2 b, float2 c, out float3 bary)
{
    float2 v0 = b - a;
    float2 v1 = c - a;
    float2 v2 = p - a;
    
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    
    float denom = d00 * d11 - d01 * d01;
    
    // Check for degenerate triangle
    if (abs(denom) < 0.0001f)
    {
        bary = float3(0, 0, 0);
        return false;
    }
    
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0f - v - w;
    
    bary = float3(u, v, w);
    
    // Check if point is inside triangle
    return (u >= 0) && (v >= 0) && (w >= 0);
}

[numthreads(8,8,1)]
void ClearTexture(uint3 id : SV_DispatchThreadID)
{
    // Make sure we don't write outside the texture
    if (id.x >= (uint)_TextureSize || id.y >= (uint)_TextureSize)
        return;
        
    // Clear the texture with transparent black
    _OutputTexture[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(8,8,1)]
void RasterizeTriangle(uint3 id : SV_DispatchThreadID)
{
    // Make sure we don't write outside the texture
    if (id.x >= (uint)_TextureSize || id.y >= (uint)_TextureSize)
        return;
        
    // Get world coordinates of triangle vertices
    float3 worldA = GetVector3(_TriangleData, 0);
    float3 worldB = GetVector3(_TriangleData, 3);
    float3 worldC = GetVector3(_TriangleData, 6);
    
    // Get UVs
    float2 uvA = GetVector2(_TriangleData, 9);
    float2 uvB = GetVector2(_TriangleData, 11);
    float2 uvC = GetVector2(_TriangleData, 13);
    
    // Convert UVs to pixel coordinates
    float2 pixelA = float2(uvA.x * _TextureSize, uvA.y * _TextureSize);
    float2 pixelB = float2(uvB.x * _TextureSize, uvB.y * _TextureSize);
    float2 pixelC = float2(uvC.x * _TextureSize, uvC.y * _TextureSize);
    
    // Current pixel
    float2 pixel = float2(id.x, id.y);
    
    // Calculate barycentric coordinates
    float3 bary;
    bool inside = BarycentricCoordinates(pixel, pixelA, pixelB, pixelC, bary);
    
    // If inside the triangle
    if (inside)
    {
        // Get camera information
        float4x4 viewMatrix = GetMatrix4x4(_TriangleData, 37);
        float4x4 projMatrix = GetMatrix4x4(_TriangleData, 21);
        
        // Interpolate world position using barycentric coordinates
        float3 worldPos = bary.x * worldA + bary.y * worldB + bary.z * worldC;
        
        // Transform to NDC coordinates
        float2 ndcPos = WorldToNDC(worldPos, viewMatrix, projMatrix);
        
        // Convert to texture coordinates [0,1]
        float2 texCoord = float2(ndcPos.x * 0.5 + 0.5, ndcPos.y * 0.5 + 0.5);
        
        // Sample the original rendered texture
        float4 sampledColor;
        if (texCoord.x >= 0 && texCoord.x <= 1 && texCoord.y >= 0 && texCoord.y <= 1)
        {
            sampledColor = _InputTexture.SampleLevel(sampler_linear_clamp, texCoord, 0);
        }
        else
        {
            sampledColor = float4(0, 0, 0, 0);
        }
        
        // Write to output texture
        _OutputTexture[id.xy] = sampledColor;
    }
}

// Helper function for line drawing
bool PointOnLine(float2 p, float2 a, float2 b, float thickness)
{
    float2 pa = p - a;
    float2 ba = b - a;
    
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    
    float2 closest = a + h * ba;
    
    return distance(p, closest) < thickness;
}

[numthreads(8,8,1)]
void DrawEdges(uint3 id : SV_DispatchThreadID)
{
    // Process this in larger chunks for performance
    const int chunkSize = 8;
    int threadsPerAxis = _TextureSize / chunkSize + (_TextureSize % chunkSize == 0 ? 0 : 1);
    
    // Only need one thread for all triangles
    if (id.x > 0 || id.y > 0 || id.z > 0) return;
    
    // Get UVs from the triangle data
    float2 uvA = GetVector2(_TriangleData, 9);
    float2 uvB = GetVector2(_TriangleData, 11);
    float2 uvC = GetVector2(_TriangleData, 13);
    
    // Convert UVs to pixel coordinates
    float2 pixelA = float2(uvA.x * _TextureSize, uvA.y * _TextureSize);
    float2 pixelB = float2(uvB.x * _TextureSize, uvB.y * _TextureSize);
    float2 pixelC = float2(uvC.x * _TextureSize, uvC.y * _TextureSize);
    
    // Compute bounding box for the triangle edges
    int minX = max(0, min(pixelA.x, min(pixelB.x, pixelC.x)) - _EdgeThickness);
    int minY = max(0, min(pixelA.y, min(pixelB.y, pixelC.y)) - _EdgeThickness);
    int maxX = min(_TextureSize - 1, max(pixelA.x, max(pixelB.x, pixelC.x)) + _EdgeThickness);
    int maxY = min(_TextureSize - 1, max(pixelA.y, max(pixelB.y, pixelC.y)) + _EdgeThickness);
    
    // Loop through the bounding box to draw the edges
    for (int y = minY; y <= maxY; y++)
    {
        for (int x = minX; x <= maxX; x++)
        {
            float2 pixel = float2(x, y);
            
            // Check if this pixel is on any of the three edges
            if (PointOnLine(pixel, pixelA, pixelB, _EdgeThickness) ||
                PointOnLine(pixel, pixelB, pixelC, _EdgeThickness) ||
                PointOnLine(pixel, pixelC, pixelA, _EdgeThickness))
            {
                // Draw the edge color
                _OutputTexture[int2(x, y)] = _EdgeColor;
            }
        }
    }
}