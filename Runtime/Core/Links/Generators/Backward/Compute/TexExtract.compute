#pragma kernel OpacityContributions
#include "../../../../Gaussian/Compute/GaussianSplatting.hlsl"
#include "../../../Compute/LinkUtilities.hlsl"

struct Triangle {
    int v0;
    int v1;
    int v2;
};

RWStructuredBuffer<float3> _VertexBasePos;
RWStructuredBuffer<Triangle> _MeshIndices;
uint _IndexCount;

uint _SplatCount;
float _GlobalSigma;
static const float MAX_DISTANCE = 1e30f;


float3 ClosestPointOnTriangle(float3 p, float3 v0, float3 v1, float3 v2) {
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float3 normal = normalize(cross(edge1, edge2));

    // Project point onto the plane of the triangle
    float3 toPoint = p - v0;
    float perpDistance = dot(toPoint, normal);
    float3 projPoint = p - perpDistance * normal;

    // Compute barycentric coordinates
    float3 toProj = projPoint - v0;
    float dot11 = dot(edge1, edge1);
    float dot12 = dot(edge1, edge2);
    float dot22 = dot(edge2, edge2);
    float dot1p = dot(edge1, toProj);
    float dot2p = dot(edge2, toProj);
    float denom = dot11 * dot22 - dot12 * dot12;

    float u = (dot22 * dot1p - dot12 * dot2p) / denom;
    float v = (dot11 * dot2p - dot12 * dot1p) / denom;
    float w = 1.0f - u - v;

    // Clamp barycentric coordinates to the triangle
    if (u < 0.0f) {
        u = 0.0f;
        v = clamp(v, 0.0f, 1.0f);
        w = 1.0f - v;
    } else if (v < 0.0f) {
        v = 0.0f;
        u = clamp(u, 0.0f, 1.0f);
        w = 1.0f - u;
    } else if (w < 0.0f) {
        w = 0.0f;
        u = clamp(u, 0.0f, 1.0f);
        v = 1.0f - u;
    }

    // Compute the closest point
    return u * v1 + v * v2 + w * v0;
}


// Helper function to convert a 3x3 matrix to a 4x4 matrix
float4x4 Convert3x3To4x4(float3x3 mat3x3) {
    return float4x4(
        float4(mat3x3[0], 0.0f),
        float4(mat3x3[1], 0.0f),
        float4(mat3x3[2], 0.0f),
        float4(0.0f, 0.0f, 0.0f, 1.0f)
    );
}

// Function to convert a quaternion to a 4x4 rotation matrix
float4x4 quatToMatrix(float4 quat) {
    float3x3 rotationMat = float3x3(
        1.0f - 2.0f * (quat.y * quat.y + quat.z * quat.z),  2.0f * (quat.x * quat.y - quat.w * quat.z),  2.0f * (quat.x * quat.z + quat.w * quat.y),
        2.0f * (quat.x * quat.y + quat.w * quat.z),  1.0f - 2.0f * (quat.x * quat.x + quat.z * quat.z),  2.0f * (quat.y * quat.z - quat.w * quat.x),
        2.0f * (quat.x * quat.z - quat.w * quat.y),  2.0f * (quat.y * quat.z + quat.w * quat.x),  1.0f - 2.0f * (quat.x * quat.x + quat.y * quat.y)
    );
    return Convert3x3To4x4(rotationMat);
}

float3 dist(float3 p1, float3 p2, float3 p3, float3 extPos) {
    // Compute vectors relative to p1
    float3 v0 = p2 - p1;
    float3 v1 = p3 - p1;
    float3 v2 = extPos - p1;

    // Compute dot products
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);

    // Compute the denominator of the barycentric coordinates
    float denom = d00 * d11 - d01 * d01;

    // Compute barycentric coordinates with improved stability
    float v = (d11 * d20 - d01 * d21) / max(denom, 1e-6f);
    float w = (d00 * d21 - d01 * d20) / max(denom, 1e-6f);
    float u = 1.0f - v - w;

    // Clamp barycentric coordinates
    v = max(0.0f, v);
    w = max(0.0f, w);
    u = max(0.0f, u);

    float sum = u + v + w;
    u /= sum;
    v /= sum;
    w /= sum;

    // Compute the closest point in the triangle
    float3 closestPoint = u * p1 + v * p2 + w * p3;

    // Compute the shortest distance
    float distance = length(extPos - closestPoint);

    return float3(distance, v, w);
}

[numthreads(128, 1, 1)]
void OpacityContributions(uint3 id : SV_DispatchThreadID) {
    uint splatIndex = id.x;
    if (splatIndex >= _SplatCount) return;

    SplatData splat = LoadSplatData(splatIndex);

    float minDistances[LINK_COUNT] = { MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, 
                                      MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE };
    int minIndices[LINK_COUNT] = { -1, -1, -1, -1, -1, -1, -1, -1 };
    float baryV[LINK_COUNT] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    float baryW[LINK_COUNT] = { 0, 0, 0, 0, 0, 0, 0, 0 };

    // First pass: find closest triangles
    [loop]
    for (uint i = 0; i < _IndexCount; i++) {
        Triangle t = _MeshIndices[i];
        float3 p1 = _VertexBasePos[t.v0];
        float3 p2 = _VertexBasePos[t.v1];
        float3 p3 = _VertexBasePos[t.v2];

        // Calculate distance and barycentric coordinates
        float3 distAndBary = dist(p1, p2, p3, splat.pos);
        float d = distAndBary.x;
        float v = distAndBary.y;  // Second barycentric coordinate
        float w = distAndBary.z;  // Third barycentric coordinate

        // Insert the new distance, index, and barycentric coordinates into the sorted list
        for (uint j = 0; j < LINK_COUNT; j++) {
            if (d < minDistances[j]) {
                // Shift existing values down
                for (uint k = LINK_COUNT - 1; k > j; k--) {
                    minDistances[k] = minDistances[k - 1];
                    minIndices[k] = minIndices[k - 1];
                    baryV[k] = baryV[k - 1];
                    baryW[k] = baryW[k - 1];
                }

                // Insert the new triangle and its barycentric coordinates
                minDistances[j] = d;
                minIndices[j] = i;
                baryV[j] = v;
                baryW[j] = w;

                break;
            }
        }
    }

    float totalDist = 0.0;
    for (uint j = 0; j < LINK_COUNT; j++) {
        totalDist += minDistances[j];
    }

    // Calculate weights and store results
    SplatLink splatLinks;
    float sigmaSquared = _GlobalSigma * _GlobalSigma;
    float threshold = 0.00001;

    [unroll]
    for (uint k = 0; k < LINK_COUNT; k++) {
        float weight = 1 - (minDistances[k] / totalDist);
        splatLinks.triangleIds[k] = (weight > threshold) ? minIndices[k] : -1;
        splatLinks.triangleWeights[k] = (weight > threshold) ? weight : 0;

        // Store the barycentric coordinates
        splatLinks.triangleX[k] = (weight > threshold) ? baryV[k] : 0;
        splatLinks.triangleY[k] = (weight > threshold) ? baryW[k] : 0;
    }

    SetSplatLink(splatIndex, splatLinks);
}