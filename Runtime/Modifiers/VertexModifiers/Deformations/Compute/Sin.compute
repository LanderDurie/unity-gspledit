#pragma kernel CSMain

RWStructuredBuffer<float3> _VertexBasePos;
RWStructuredBuffer<float3> _VertexModPos;

// Buffers
RWByteAddressBuffer _VertexSelectedBits;

// Time and animation parameters
float time;
float amplitudeX;
float amplitudeY;
float amplitudeZ;
float frequencyX;
float frequencyY;
float frequencyZ;
float phaseX;
float phaseY;
float phaseZ;
float3 animateFlags; // Vector3 to store which axes to animate (x,y,z)

// Helper function to check if vertex is selected
bool isSelected(uint idx) {
    uint wordIndex = idx >> 5;  // Divide by 32 to get word index
    uint bitPosition = idx & 31; // Get position within the 32-bit word (0-31)
    uint selectionWord = _VertexSelectedBits.Load(wordIndex * 4);
    // Extract the specific bit for this vertex
    uint isBitSet = (selectionWord >> bitPosition) & 1;
    return isBitSet;
}

// Thread group size
[numthreads(256, 1, 1)]
void CSMain(uint id : SV_DispatchThreadID)
{
    // Ensure we don't go out of bounds
    if (id >= _VertexBasePos.Length)
        return;
       
    // Check if vertex is selected
    if (!isSelected(id))
        return;
       
    // Read the current vertex
    float3 basePos = _VertexBasePos[id];
    float3 modPos = _VertexModPos[id];

    // IMPORTANT: Reset posMod to zero first to avoid accumulation
    modPos = float3(0, 0, 0);
   
    // For X axis
    float timeValueX = animateFlags.x > 0 ? time : 0;
    // X axis deformation - using pos.x and pos.z for variation
    modPos.x = sin((timeValueX + basePos.x * frequencyX) + phaseX) * amplitudeX;
    
    // For Y axis
    float timeValueY = animateFlags.y > 0 ? time : 0;
    // Y axis deformation - using pos.z for variation
    modPos.y = sin((timeValueY + basePos.z * frequencyY) + phaseY) * amplitudeY;
    
    // For Z axis
    float timeValueZ = animateFlags.z > 0 ? time : 0;
    // Z axis deformation
    modPos.z = sin((timeValueZ + basePos.y * frequencyZ) + phaseZ) * amplitudeZ;
   
    // Write back the modified vertex
    _VertexModPos[id] = modPos + basePos;
}